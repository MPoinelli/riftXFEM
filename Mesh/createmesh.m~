function [ncoord,eco,bnodes,enodes] = createmesh(ndiv,air)
%
%Purpose
%Generate Q4 or T3 mesh for given domain dimensions and identify boundary
%nodes. T3 is generated by splitting one Q4 into two elements diagonally
%Variables
%L, D - dimensions of the domain
%nxdiv, nydiv - number of elements in X- and Y- direction
%ncoord - nodal coordinates
%eco - element connectivity matrix
%bnodes - cell containing boundary nodes
%--------------------------------------------------------------------------
global L D
global elemType typeCrack

disp([num2str(toc),'    Mesh Generation'])

pt1 = [0 -L/2]; pt2 = [D -L/2]; pt3 = [D L/2]; pt4 = [0 L/2];

nxdiv = ndiv(1) ;
nydiv = 2*ndiv(1) ;

[ncoord,eco] = meshRectangularRegion(pt1,pt2,pt3,pt4,nxdiv,nydiv,elemType) ;

%generate distorted mesh. this is done by giving small perturbation to each
%node in the domain. the element connectivity remains the same
if( air > 0 )
    dx = L/nxdiv; dy = L/nydiv ;
    gcoord = ncoord ;
    nn = 0 ;
    for ip = 1:nxdiv
        for iq = 1:nydiv
            nn = nn+1 ;
            r = rand(1) ;
            r = air*(2*r-1) ;
            if( ip == 1 | ip == nxdiv | iq == 1 | iq == nydiv)
                r = 0 ;
            end
            gcoord(nn,1) = gcoord(nn,1)+ dx*r ;
            gcoord(nn,2) = gcoord(nn,2)+ dy*r ;
        end
    end
    clear nn ;
    ncoord = gcoord ;
end
    
%identify boundary nodes
nnx = nxdiv ; nny = nydiv ;

uln = nnx*(nny-1)+1 ;
urn = nnx*nny ;
lrn = nnx ;
lln = 1 ;
cln = nnx*(nny-1)/2+1 ;

rightEdge = [lrn:nnx:(uln-1); (lrn+nnx):nnx:urn ]' ;
leftEdge = [ uln:-nnx:(lrn+1); (uln-nnx):-nnx:1 ]' ;
topEdge  = [ uln:1:(urn-1); (uln+1):1:urn ]' ;
botEdge  = [ lln:1:(lrn-1); (lln+1):1:lrn ]' ;

botNodes = unique(botEdge) ;
rightNodes = unique(rightEdge) ;
topNodes = unique(topEdge) ;
leftNodes = unique(leftEdge) ;

bnodes = {botNodes rightNodes topNodes leftNodes} ;
enodes = {botEdge rightEdge topEdge leftEdge} ;